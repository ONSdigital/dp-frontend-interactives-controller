/*
Download service

A service used to download files from private or public s3 buckets.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// PublicApiService PublicApi service
type PublicApiService service

type ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	datasetID string
	edition string
	version string
}

func (r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetExecute(r)
}

/*
DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGet Download the full csv for a given datasetID, edition and version

Request a download for the full CSV for a given datasetID, edition and version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param datasetID The unique identifier for a dataset.
 @param edition An edition of a dataset
 @param version A version of a dataset
 @return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest
*/
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGet(ctx context.Context, datasetID string, edition string, version string) ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest {
	return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest{
		ApiService: a,
		ctx: ctx,
		datasetID: datasetID,
		edition: edition,
		version: version,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetExecute(r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloads/datasets/{datasetID}/editions/{edition}/versions/{version}.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"datasetID"+"}", url.PathEscape(parameterToString(r.datasetID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edition"+"}", url.PathEscape(parameterToString(r.edition, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	datasetID string
	edition string
	version string
}

func (r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetExecute(r)
}

/*
DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGet Download the csv metadata for a given datasetID, edition and version

Request a download for the metadata for the full CSV for a given datasetID, edition and version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param datasetID The unique identifier for a dataset.
 @param edition An edition of a dataset
 @param version A version of a dataset
 @return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest
*/
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGet(ctx context.Context, datasetID string, edition string, version string) ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest {
	return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest{
		ApiService: a,
		ctx: ctx,
		datasetID: datasetID,
		edition: edition,
		version: version,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetExecute(r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionCsvMetadataJsonGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloads/datasets/{datasetID}/editions/{edition}/versions/{version}.csv-metadata.json"
	localVarPath = strings.Replace(localVarPath, "{"+"datasetID"+"}", url.PathEscape(parameterToString(r.datasetID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edition"+"}", url.PathEscape(parameterToString(r.edition, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/csvm+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	datasetID string
	edition string
	version string
}

func (r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetExecute(r)
}

/*
DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGet Download the full excel file for a given datasetID, edition and version

Request a download for the full Excel file for a given datasetID, edition and version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param datasetID The unique identifier for a dataset.
 @param edition An edition of a dataset
 @param version A version of a dataset
 @return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest
*/
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGet(ctx context.Context, datasetID string, edition string, version string) ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest {
	return ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest{
		ApiService: a,
		ctx: ctx,
		datasetID: datasetID,
		edition: edition,
		version: version,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetExecute(r ApiDownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.DownloadsDatasetsDatasetIDEditionsEditionVersionsVersionXlsxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloads/datasets/{datasetID}/editions/{edition}/versions/{version}.xlsx"
	localVarPath = strings.Replace(localVarPath, "{"+"datasetID"+"}", url.PathEscape(parameterToString(r.datasetID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edition"+"}", url.PathEscape(parameterToString(r.edition, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.ms-excel"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	filterOutputID string
}

func (r ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadsFilterOutputsFilterOutputIDCsvGetExecute(r)
}

/*
DownloadsFilterOutputsFilterOutputIDCsvGet Download a filtered csv file for a given filter output id

Request a download for a filtered csv file for a given filter ouput id which has selected dimension values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filterOutputID The unique identifier for a filter output job
 @return ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest
*/
func (a *PublicApiService) DownloadsFilterOutputsFilterOutputIDCsvGet(ctx context.Context, filterOutputID string) ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest {
	return ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest{
		ApiService: a,
		ctx: ctx,
		filterOutputID: filterOutputID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) DownloadsFilterOutputsFilterOutputIDCsvGetExecute(r ApiDownloadsFilterOutputsFilterOutputIDCsvGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.DownloadsFilterOutputsFilterOutputIDCsvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloads/filter-outputs/{filterOutputID}.csv"
	localVarPath = strings.Replace(localVarPath, "{"+"filterOutputID"+"}", url.PathEscape(parameterToString(r.filterOutputID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	filterOutputID string
}

func (r ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.DownloadsFilterOutputsFilterOutputIDXlsxGetExecute(r)
}

/*
DownloadsFilterOutputsFilterOutputIDXlsxGet Download a filtered excel file for a given filter output id

Request a download for a filtered excel file for a given filter ouput id which has selected dimension values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filterOutputID The unique identifier for a filter output job
 @return ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest
*/
func (a *PublicApiService) DownloadsFilterOutputsFilterOutputIDXlsxGet(ctx context.Context, filterOutputID string) ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest {
	return ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest{
		ApiService: a,
		ctx: ctx,
		filterOutputID: filterOutputID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) DownloadsFilterOutputsFilterOutputIDXlsxGetExecute(r ApiDownloadsFilterOutputsFilterOutputIDXlsxGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.DownloadsFilterOutputsFilterOutputIDXlsxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloads/filter-outputs/{filterOutputID}.xlsx"
	localVarPath = strings.Replace(localVarPath, "{"+"filterOutputID"+"}", url.PathEscape(parameterToString(r.filterOutputID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImagesImageIDVariantFilenameGetRequest struct {
	ctx context.Context
	ApiService *PublicApiService
	imageID string
	variant string
	filename string
}

func (r ApiImagesImageIDVariantFilenameGetRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.ImagesImageIDVariantFilenameGetExecute(r)
}

/*
ImagesImageIDVariantFilenameGet Download an image variant

Request a download of a specific variant of an image as created by the image importer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageID The unique identifier for an image.
 @param variant The variant of an image to download
 @param filename The filename of the file to download
 @return ApiImagesImageIDVariantFilenameGetRequest
*/
func (a *PublicApiService) ImagesImageIDVariantFilenameGet(ctx context.Context, imageID string, variant string, filename string) ApiImagesImageIDVariantFilenameGetRequest {
	return ApiImagesImageIDVariantFilenameGetRequest{
		ApiService: a,
		ctx: ctx,
		imageID: imageID,
		variant: variant,
		filename: filename,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PublicApiService) ImagesImageIDVariantFilenameGetExecute(r ApiImagesImageIDVariantFilenameGetRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.ImagesImageIDVariantFilenameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{imageID}/{variant}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"imageID"+"}", url.PathEscape(parameterToString(r.imageID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant"+"}", url.PathEscape(parameterToString(r.variant, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterToString(r.filename, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
